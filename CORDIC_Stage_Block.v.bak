
module CORDIC Stage (
	input clk,
	input rst,
	input sign_in,
	input [7:0] ite,
	input [31:0] target,
	input [31:0] arctan_in_1,
	input [31:0] arctan_in_2,
	input [32:0] curr_angle_in,
	input [32:0] x_in,
	input [32:0] y_in,
	output sign_out,
	output [32:0] curr_angle_out,
	output [32:0] x_out,
	output [32:0] y_out
	);
	
	//Register Initialisations
	reg sign;
	reg [32:0] x[0:1];
	reg [32:0] y[0:1];
	//Used as temps for bit inversions or shifts
	reg [32:0] y_tmp[0:3];
	reg [32:0] x_tmp[0:3];
	//Number of shifts required: 2^i
	reg [3:0] count[0:1];
	reg [32:0] current_angle[0:1];
	//Temp value that allows use to convert arctan(1/2^i) to 2's complement
	reg [32:0] atan[0:3];

	
	always @(posedge) begin
			
			sign = sign_in;
			count[0] = ite[7:4];
			//Make y negative fs sign is negative
			y_tmp[0] = sign ? y_in : ~y_in+1;
			//Right shift, but without affecting MSB
			y_tmp[1] = {y_tmp[0][32], y_tmp[0][31:0]>>count[0]};
			//Make y negative is sign is negative
			x_tmp[0] = sign ? x_in : ~x_in+1;
			//Right shift, but without affecting MSB
			x_tmp[1] = {x_tmp[0][32], x_tmp[0][31:0]>>count[0]};
			
			//Calculate x and y without any multiplication
			x[0] = x_in + y_tmp[1];
			y[0] = x_tmp[1] + y_in;
			
			//Load 32-bits from atan LUT into 33 bit atan for sign representaiton
			atan[0][31:0] = arctan_in_1[31:0];
			//Make atan negative if sign is negative
			atan[1] = sign ? atan[0] : ~atan[0]+1;
			//Find current angle without multiplication
			current_angle[0] = curr_angle_in + atan[1];
			
			//Checks if current angle is negative
			if (current_angle[32]) begin
				sign = 1'b1;
			end
			else if (current_angle[31:0] > target) begin
				sign = 1'b0;
			else begin
				sign = 1'b1;
			end
			
			//Repeats the above
			
			count[1] = ite[3:0];
			y_tmp[2] = sign ? y_[0] : ~y_[0]+1;
			y_tmp[3] = {y_tmp[2][32], y_tmp[2][31:0]>>count[1]};
			x_tmp[2] = sign ? x[0] : ~x[0]+1;
			x_tmp[3] = {x_tmp[2][32], x_tmp[2][31:0]>>count[1]};
			
			x[1] = x_[0] + y_tmp[3];
			y[1] = x_tmp[3] + y_[0];
			
			atan[2][31:0] = arctan_in_2[31:0];
			atan[3] = sign ? atan[2] : ~atan[2]+1;
			current_angle[1] = currrent_angle[0] + atan[3];
			
			if (current_angle[32]) begin
				sign = 1'b1;
			end
			else if (current_angle[31:0] > target) begin
				sign = 1'b0;
			else begin
				sign = 1'b1;
			end
			
	end
		
	assign sign_out = sign;
	assign curr_angle_out = current_angle[1];
	assign x_out = x[1];
	assign y_out = y[1];
			
endmodule